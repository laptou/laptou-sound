---
description: Better Auth authentication patterns for TanStack Start with SolidJS
globs: ["src/lib/auth*.ts", "src/routes/auth/**/*.tsx", "src/server/**/*.ts"]
---

# Better Auth with TanStack Start (SolidJS)

## IMPORTANT: Database Access Pattern

**CRITICAL**: Better Auth uses **kysely-d1** for database access, NOT Drizzle ORM.

- Better Auth manages its own tables: `user`, `session`, `account`, `verification`
- Do NOT use Drizzle for Better Auth tables
- Do NOT use raw D1 queries for Better Auth - use kysely-d1 via Better Auth's internal adapter

## Server-Side Auth Instance

Create the auth instance in `src/lib/auth.ts`:

```typescript
import { betterAuth } from "better-auth";
import { Kysely } from "kysely";
import { D1Dialect } from "kysely-d1";
import type { D1Database } from "@cloudflare/workers-types";

export function createAuth(db: D1Database) {
  // create kysely instance for better auth
  const kysely = new Kysely<any>({
    dialect: new D1Dialect({ database: db }),
  });

  return betterAuth({
    database: {
      provider: "sqlite",
      url: "", // not used for d1
    },
    emailAndPassword: {
      enabled: true,
      requireEmailVerification: false,
    },
    session: {
      expiresIn: 60 * 60 * 24 * 7, // 7 days
      updateAge: 60 * 60 * 24, // update session every day
    },
    // use kysely-d1 for database queries
    advanced: {
      database: {
        async executeQuery({ query, params }) {
          const result = await kysely.executeQuery({
            query: query as any,
            params: params || [],
          });
          return result.rows || [];
        },
      },
    },
  });
}
```

## Client-Side Auth

Create auth client in `src/lib/auth-client.ts`:

```typescript
import { createAuthClient } from "better-auth/solid";

export const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_APP_URL,
});

export const { signIn, signUp, signOut, useSession } = authClient;
```

## API Route Handler

Create API route at `src/routes/api/auth/$.ts`:

```typescript
import { createAPIFileRoute } from "@tanstack/solid-start/api";
import { auth } from "~/lib/auth";

export const APIRoute = createAPIFileRoute("/api/auth/$")({
  GET: async ({ request }) => auth.handler(request),
  POST: async ({ request }) => auth.handler(request),
});
```

## Session Access in Server Functions

```typescript
import { createServerFn } from "@tanstack/solid-start/server";
import { auth } from "~/lib/auth";
import { getWebRequest } from "@tanstack/solid-start/server";

const getSession = createServerFn({ method: "GET" }).handler(async () => {
  const request = getWebRequest();
  const session = await auth.api.getSession({ headers: request.headers });
  return session;
});
```

## Protected Routes

Use `beforeLoad` to protect routes:

```typescript
import { createFileRoute, redirect } from "@tanstack/solid-router";

export const Route = createFileRoute("/protected")({
  beforeLoad: async ({ context }) => {
    const session = await getSession();
    if (!session) {
      throw redirect({ to: "/auth/login" });
    }
    return { session };
  },
  component: ProtectedPage,
});
```

## Role-Based Authorization

Check user roles in server functions:

```typescript
const requireRole = (allowedRoles: string[]) =>
  createServerFn({ method: "GET" }).handler(async () => {
    const request = getWebRequest();
    const session = await auth.api.getSession({ headers: request.headers });
    
    if (!session?.user) {
      throw new Error("Unauthorized");
    }
    
    // query user_role table
    const role = await getUserRole(session.user.id);
    if (!allowedRoles.includes(role)) {
      throw new Error("Forbidden");
    }
    
    return { session, role };
  });
```

## Key Patterns

1. Always use `getWebRequest()` to access request headers in server functions
2. Store custom user data (roles) in separate tables linked by userId
3. Use `beforeLoad` for route-level auth checks
4. Handle auth state reactively with `useSession()` on client
5. Never expose sensitive auth logic to the client bundle
