---
description: TanStack Start server routes (API endpoints) - CRITICAL CORRECTIONS
globs: ["src/routes/api/**/*.ts", "src/routes/**/*.ts"]
---

# TanStack Start Server Routes (API Endpoints)

> Reference: https://tanstack.com/start/latest/docs/framework/solid/guide/server-routes

## ⚠️ CRITICAL CORRECTION

**`createAPIFileRoute` DOES NOT EXIST!** This function is NOT part of TanStack Start.

Server routes are created using `createFileRoute` with a `server` property:

```typescript
// ❌ WRONG - this function does not exist
import { createAPIFileRoute } from "@tanstack/solid-start/api";
export const APIRoute = createAPIFileRoute("/api/users")({ ... });

// ✅ CORRECT - use createFileRoute with server property
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/users")({
  server: {
    handler: {
      GET: async ({ request, params }) => {
        return json({ users: [] });
      },
    },
  },
});
```

## What are Server Routes?

Server routes are HTTP endpoints that handle raw requests (GET, POST, PUT, DELETE, etc.).
They're defined in the same `src/routes/` directory as page routes using the same file conventions.

## Basic Server Route

```typescript
// src/routes/api/health.ts
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/health")({
  server: {
    handler: {
      GET: async () => {
        return json({ status: "ok", timestamp: Date.now() });
      },
    },
  },
});
```

## Handler Methods

Server routes can handle any HTTP method:

```typescript
// src/routes/api/users.ts
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/users")({
  server: {
    handler: {
      // GET /api/users
      GET: async ({ request }) => {
        const users = await db.users.findMany();
        return json(users);
      },
      
      // POST /api/users
      POST: async ({ request }) => {
        const body = await request.json();
        const user = await db.users.create(body);
        return json(user, { status: 201 });
      },
      
      // PUT /api/users
      PUT: async ({ request }) => {
        const body = await request.json();
        const user = await db.users.update(body);
        return json(user);
      },
      
      // DELETE /api/users
      DELETE: async ({ request }) => {
        const url = new URL(request.url);
        const id = url.searchParams.get("id");
        await db.users.delete(id);
        return json({ deleted: true });
      },
    },
  },
});
```

## Handler Context

Each handler receives an object with:

- `request` - The incoming Request object (Web API standard)
- `params` - Dynamic path parameters from the URL
- `context` - Context from middleware (including Cloudflare bindings)

```typescript
export const Route = createFileRoute("/api/users/$userId")({
  server: {
    handler: {
      GET: async ({ request, params, context }) => {
        // request - Web API Request
        const url = new URL(request.url);
        const format = url.searchParams.get("format");
        
        // params - dynamic segments
        const userId = params.userId;
        
        // context - middleware/platform context
        const env = context.cloudflare?.env;
        
        return json({ userId });
      },
    },
  },
});
```

## Dynamic Parameters

```typescript
// src/routes/api/users/$userId.ts
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/users/$userId")({
  server: {
    handler: {
      GET: async ({ params }) => {
        // params.userId is typed as string
        const user = await db.users.findById(params.userId);
        
        if (!user) {
          return new Response("User not found", { status: 404 });
        }
        
        return json(user);
      },
    },
  },
});
```

## Wildcard/Splat Routes

```typescript
// src/routes/api/files/$.ts
import { createFileRoute } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/files/$")({
  server: {
    handler: {
      GET: async ({ params, context }) => {
        // params._splat contains the rest of the path
        // /api/files/images/photo.jpg -> _splat = "images/photo.jpg"
        const filePath = params._splat;
        
        const file = await storage.get(filePath);
        if (!file) {
          return new Response("Not found", { status: 404 });
        }
        
        return new Response(file.body, {
          headers: {
            "Content-Type": file.httpMetadata?.contentType || "application/octet-stream",
          },
        });
      },
    },
  },
});
```

## Cloudflare Integration

```typescript
// src/routes/api/data.ts
import { createFileRoute, json } from "@tanstack/solid-router";
import type { D1Database, R2Bucket } from "@cloudflare/workers-types";

export const Route = createFileRoute("/api/data")({
  server: {
    handler: {
      GET: async ({ context }) => {
        // access cloudflare bindings from context
        const env = (context as any).cloudflare?.env;
        const db = env?.DB as D1Database | undefined;
        const r2 = env?.R2 as R2Bucket | undefined;
        
        if (!db) {
          return new Response("Database not configured", { status: 500 });
        }
        
        const { results } = await db.prepare("SELECT * FROM items").all();
        return json(results);
      },
    },
  },
});
```

## Authentication in Server Routes

```typescript
// src/routes/api/protected.ts
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/protected")({
  server: {
    handler: {
      POST: async ({ request, context }) => {
        // parse session from cookies
        const cookies = request.headers.get("cookie") || "";
        const sessionToken = cookies
          .split(";")
          .find((c) => c.trim().startsWith("session="))
          ?.split("=")[1];
        
        if (!sessionToken) {
          return new Response("Unauthorized", { status: 401 });
        }
        
        // verify session
        const session = await verifySession(sessionToken);
        if (!session) {
          return new Response("Invalid session", { status: 401 });
        }
        
        // proceed with authenticated request
        const body = await request.json();
        return json({ success: true, userId: session.userId });
      },
    },
  },
});
```

## Server Route Middleware

```typescript
// src/routes/api/_authenticated.ts (pathless layout for middleware)
import { createFileRoute } from "@tanstack/solid-router";
import { createMiddleware } from "@tanstack/solid-start/server";

const authMiddleware = createMiddleware()
  .server(async ({ next, request }) => {
    const session = await getSession(request);
    if (!session) {
      return new Response("Unauthorized", { status: 401 });
    }
    return next({ context: { session } });
  });

export const Route = createFileRoute("/api/_authenticated")({
  server: {
    middleware: [authMiddleware],
  },
});

// Child routes automatically get middleware:
// src/routes/api/_authenticated/user.ts
```

## Route with Both Page and Server

You can define both a page component AND server handlers in the same file:

```typescript
// src/routes/users.tsx
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/users")({
  // page component
  component: UsersPage,
  loader: async () => {
    return fetchUsers();
  },
  
  // server handlers for same path
  server: {
    handler: {
      POST: async ({ request }) => {
        const body = await request.json();
        const user = await createUser(body);
        return json(user, { status: 201 });
      },
    },
  },
});

function UsersPage() {
  const users = Route.useLoaderData();
  return <For each={users()}>{(u) => <div>{u.name}</div>}</For>;
}
```

## File Upload Handling

```typescript
// src/routes/api/upload.ts
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/upload")({
  server: {
    handler: {
      POST: async ({ request, context }) => {
        const env = (context as any).cloudflare?.env;
        const r2 = env?.R2;
        
        if (!r2) {
          return new Response("Storage not configured", { status: 500 });
        }
        
        const contentType = request.headers.get("content-type") || "application/octet-stream";
        const body = await request.arrayBuffer();
        
        const key = `uploads/${Date.now()}`;
        await r2.put(key, body, {
          httpMetadata: { contentType },
        });
        
        return json({ key, size: body.byteLength });
      },
    },
  },
});
```

## Response Helpers

```typescript
import { createFileRoute, json } from "@tanstack/solid-router";

export const Route = createFileRoute("/api/example")({
  server: {
    handler: {
      GET: async () => {
        // json helper - sets Content-Type automatically
        return json({ data: "value" });
        
        // with status code
        return json({ error: "Not found" }, { status: 404 });
        
        // with custom headers
        return json({ data: "value" }, {
          headers: {
            "Cache-Control": "max-age=3600",
          },
        });
      },
      
      POST: async () => {
        // raw Response for non-JSON
        return new Response("Plain text", {
          headers: { "Content-Type": "text/plain" },
        });
        
        // redirect
        return new Response(null, {
          status: 302,
          headers: { Location: "/new-path" },
        });
      },
    },
  },
});
```

## File Route Conventions for Server Routes

| File Pattern | URL Path |
|-------------|----------|
| `routes/api/users.ts` | `/api/users` |
| `routes/api/users/index.ts` | `/api/users` |
| `routes/api/users/$id.ts` | `/api/users/:id` |
| `routes/api/users/$id/posts.ts` | `/api/users/:id/posts` |
| `routes/api/files/$.ts` | `/api/files/*` (wildcard) |
| `routes/api/script[.]js.ts` | `/api/script.js` (escaped dot) |

## Best Practices

1. **Use `createFileRoute` with `server` property** - NOT `createAPIFileRoute`
2. **Return proper HTTP status codes** - 200, 201, 400, 401, 404, 500, etc.
3. **Validate request body** - Check and parse JSON before using
4. **Handle errors gracefully** - Return appropriate error responses
5. **Use middleware for shared auth** - Avoid duplicating auth logic
6. **Set appropriate headers** - Content-Type, Cache-Control, CORS if needed
