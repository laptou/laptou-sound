---
description: Rules for using Cloudflare R2 object storage
globs:
  - src/server/upload*.ts
  - src/server/files*.ts
  - src/routes/**/upload**
---
# Cloudflare R2 Object Storage

## Accessing the R2 Binding

```typescript
import { env } from "cloudflare:workers";

// binding name from wrangler.jsonc
const bucket = env.laptou_sound_files;
```

## R2 Key Structure for Audio Files

```
tracks/
  {trackId}/
    versions/
      {versionId}/
        original.{ext}     # original uploaded file
        stream.mp3         # 128kbps transcoded version
        waveform.json      # pre-computed waveform data
```

## Uploading Files

```typescript
import { env } from "cloudflare:workers";

export async function uploadFile(
  key: string,
  data: ArrayBuffer | ReadableStream,
  contentType: string
) {
  const bucket = env.laptou_sound_files;
  
  await bucket.put(key, data, {
    httpMetadata: {
      contentType,
    },
  });
}
```

## Downloading Files

```typescript
import { env } from "cloudflare:workers";

export async function getFile(key: string) {
  const bucket = env.laptou_sound_files;
  const object = await bucket.get(key);
  
  if (!object) {
    return null;
  }
  
  return {
    body: object.body,
    contentType: object.httpMetadata?.contentType,
    size: object.size,
  };
}
```

## Serving Files via Server Route

```typescript
// src/routes/files/$.ts
import { createFileRoute } from "@tanstack/solid-router";
import { env } from "cloudflare:workers";

export const Route = createFileRoute("/files/$")({
  server: {
    handlers: {
      GET: async ({ params }) => {
        const key = params._splat;
        const bucket = env.laptou_sound_files;
        const object = await bucket.get(key);
        
        if (!object) {
          return new Response("Not found", { status: 404 });
        }
        
        return new Response(object.body, {
          headers: {
            "Content-Type": object.httpMetadata?.contentType || "application/octet-stream",
            "Cache-Control": "public, max-age=31536000",
          },
        });
      },
    },
  },
});
```

## Handling File Uploads in Server Functions

```typescript
import { createServerFn } from "@tanstack/solid-start";
import { getWebRequest } from "@tanstack/solid-start/server";
import { env } from "cloudflare:workers";

export const uploadTrack = createServerFn({ method: "POST" }).handler(async () => {
  const request = getWebRequest();
  const formData = await request.formData();
  const file = formData.get("file") as File;
  
  if (!file) {
    throw new Error("No file provided");
  }
  
  const trackId = crypto.randomUUID();
  const versionId = crypto.randomUUID();
  const ext = file.name.split(".").pop();
  const key = `tracks/${trackId}/versions/${versionId}/original.${ext}`;
  
  const bucket = env.laptou_sound_files;
  await bucket.put(key, await file.arrayBuffer(), {
    httpMetadata: {
      contentType: file.type,
    },
  });
  
  return { trackId, versionId, key };
});
```

## Deleting Files

```typescript
import { env } from "cloudflare:workers";

export async function deleteFile(key: string) {
  const bucket = env.laptou_sound_files;
  await bucket.delete(key);
}

// delete all files for a track version
export async function deleteTrackVersion(trackId: string, versionId: string) {
  const bucket = env.laptou_sound_files;
  const prefix = `tracks/${trackId}/versions/${versionId}/`;
  
  const listed = await bucket.list({ prefix });
  for (const object of listed.objects) {
    await bucket.delete(object.key);
  }
}
```

## Listing Objects

```typescript
import { env } from "cloudflare:workers";

export async function listTrackVersions(trackId: string) {
  const bucket = env.laptou_sound_files;
  const prefix = `tracks/${trackId}/versions/`;
  
  const listed = await bucket.list({ prefix, delimiter: "/" });
  return listed.delimitedPrefixes; // returns version folder paths
}
```
