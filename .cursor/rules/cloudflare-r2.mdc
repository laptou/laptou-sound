---
description: Cloudflare R2 object storage patterns for TanStack Start
globs: ["src/lib/storage*.ts", "src/server/**/*.ts", "wrangler.jsonc"]
---

# Cloudflare R2 with TanStack Start

## Wrangler Configuration

Add R2 binding in `wrangler.jsonc`:

```jsonc
{
  "r2_buckets": [
    {
      "binding": "R2",
      "bucket_name": "laptou-sound-files"
    }
  ]
}
```

## Creating R2 Bucket

```bash
# create bucket
bun wrangler r2 bucket create laptou-sound-files

# list buckets
bun wrangler r2 bucket list
```

## Bucket Structure for Audio Platform

```
/originals/{trackId}/{versionId}/{filename}     - Original uploaded files
/playback/{trackId}/{versionId}/audio.mp3       - 128kbps playback version
/waveforms/{trackId}/{versionId}/peaks.json     - Waveform data
/covers/{trackId}/{filename}                     - Cover art images
```

## Uploading Files

```typescript
import { createServerFn } from "@tanstack/solid-start/server";
import { getCloudflareContext } from "@tanstack/solid-start/server";

const uploadFile = createServerFn({ method: "POST" })
  .validator((data: { key: string; body: ArrayBuffer; contentType: string }) => data)
  .handler(async ({ data }) => {
    const { env } = await getCloudflareContext();
    
    await env.R2.put(data.key, data.body, {
      httpMetadata: {
        contentType: data.contentType,
      },
    });
    
    return { key: data.key };
  });
```

## Downloading Files

```typescript
const getFile = createServerFn({ method: "GET" })
  .validator((key: string) => key)
  .handler(async ({ data: key }) => {
    const { env } = await getCloudflareContext();
    
    const object = await env.R2.get(key);
    if (!object) {
      throw new Error("File not found");
    }
    
    return {
      body: await object.arrayBuffer(),
      contentType: object.httpMetadata?.contentType,
    };
  });
```

## Generating Presigned URLs for Direct Upload

For large file uploads, use presigned URLs to upload directly to R2:

```typescript
import { AwsClient } from "aws4fetch";

const getUploadUrl = createServerFn({ method: "GET" })
  .validator((data: { key: string; contentType: string }) => data)
  .handler(async ({ data }) => {
    const { env } = await getCloudflareContext();
    
    // R2 uses S3-compatible API
    const client = new AwsClient({
      accessKeyId: env.R2_ACCESS_KEY_ID,
      secretAccessKey: env.R2_SECRET_ACCESS_KEY,
    });
    
    const url = new URL(
      `https://${env.CF_ACCOUNT_ID}.r2.cloudflarestorage.com/${env.R2_BUCKET_NAME}/${data.key}`
    );
    
    const signed = await client.sign(
      new Request(url, {
        method: "PUT",
        headers: { "Content-Type": data.contentType },
      }),
      { aws: { signQuery: true } }
    );
    
    return signed.url;
  });
```

## Streaming Large Files

```typescript
// API route for streaming file downloads
import { createAPIFileRoute } from "@tanstack/solid-start/api";

export const APIRoute = createAPIFileRoute("/api/files/$key")({
  GET: async ({ request, params }) => {
    const { env } = await getCloudflareContext();
    const key = params.key;
    
    const object = await env.R2.get(key);
    if (!object) {
      return new Response("Not found", { status: 404 });
    }
    
    return new Response(object.body, {
      headers: {
        "Content-Type": object.httpMetadata?.contentType || "application/octet-stream",
        "Content-Length": object.size.toString(),
        "Cache-Control": "public, max-age=31536000",
      },
    });
  },
});
```

## Deleting Files

```typescript
const deleteFile = createServerFn({ method: "POST" })
  .validator((key: string) => key)
  .handler(async ({ data: key }) => {
    const { env } = await getCloudflareContext();
    await env.R2.delete(key);
  });

// Delete multiple files
const deleteFiles = createServerFn({ method: "POST" })
  .validator((keys: string[]) => keys)
  .handler(async ({ data: keys }) => {
    const { env } = await getCloudflareContext();
    await env.R2.delete(keys);
  });
```

## Listing Objects

```typescript
const listFiles = createServerFn({ method: "GET" })
  .validator((prefix: string) => prefix)
  .handler(async ({ data: prefix }) => {
    const { env } = await getCloudflareContext();
    
    const listed = await env.R2.list({ prefix, limit: 100 });
    
    return listed.objects.map((obj) => ({
      key: obj.key,
      size: obj.size,
      uploaded: obj.uploaded,
    }));
  });
```

## Key Patterns

1. Use `getCloudflareContext()` to access R2 binding
2. Structure keys hierarchically for easy listing/deletion
3. Set appropriate `Content-Type` when uploading
4. Use streaming responses for large files
5. Consider presigned URLs for direct client uploads (reduces server bandwidth)
6. Set cache headers for static assets
7. Delete related files when deleting parent resources
