---
description: Cloudflare Queues patterns for async audio processing
globs: ["src/workers/**/*.ts", "src/lib/queue*.ts", "wrangler.jsonc"]
---

# Cloudflare Queues for Audio Processing

## Wrangler Configuration

Add Queue bindings in `wrangler.jsonc`:

```jsonc
{
  "queues": {
    "producers": [
      {
        "binding": "AUDIO_QUEUE",
        "queue": "audio-processing"
      }
    ],
    "consumers": [
      {
        "queue": "audio-processing",
        "max_batch_size": 1,
        "max_retries": 3,
        "dead_letter_queue": "audio-processing-dlq"
      }
    ]
  }
}
```

## Creating Queues

```bash
# create the processing queue
bun wrangler queues create audio-processing

# create dead letter queue for failed jobs
bun wrangler queues create audio-processing-dlq
```

## Message Types

Define your message types:

```typescript
// src/lib/queue/types.ts
export interface AudioProcessingMessage {
  type: "process_audio";
  trackId: string;
  versionId: string;
  originalKey: string;
  targetPlaybackKey: string;
  targetWaveformKey: string;
}

export interface ProcessingResultMessage {
  type: "processing_complete" | "processing_failed";
  trackId: string;
  versionId: string;
  duration?: number;
  error?: string;
}
```

## Sending Messages (Producer)

```typescript
import { createServerFn } from "@tanstack/solid-start/server";
import { getCloudflareContext } from "@tanstack/solid-start/server";
import type { AudioProcessingMessage } from "~/lib/queue/types";

const queueAudioProcessing = createServerFn({ method: "POST" })
  .validator((data: AudioProcessingMessage) => data)
  .handler(async ({ data }) => {
    const { env } = await getCloudflareContext();
    
    await env.AUDIO_QUEUE.send(data);
    
    return { queued: true };
  });
```

## Queue Consumer Worker

Create a queue consumer in your worker:

```typescript
// src/workers/audio-processor.ts
import type { AudioProcessingMessage } from "~/lib/queue/types";

export interface Env {
  DB: D1Database;
  R2: R2Bucket;
  AUDIO_QUEUE: Queue<AudioProcessingMessage>;
}

export default {
  async queue(
    batch: MessageBatch<AudioProcessingMessage>,
    env: Env,
    ctx: ExecutionContext
  ): Promise<void> {
    for (const message of batch.messages) {
      try {
        await processAudioMessage(message.body, env);
        message.ack();
      } catch (error) {
        console.error("Processing failed:", error);
        message.retry();
      }
    }
  },
};

async function processAudioMessage(
  msg: AudioProcessingMessage,
  env: Env
): Promise<void> {
  // update status to processing
  await env.DB.prepare(
    `UPDATE track_version SET processing_status = 'processing' WHERE id = ?`
  ).bind(msg.versionId).run();

  try {
    // fetch original file from R2
    const original = await env.R2.get(msg.originalKey);
    if (!original) throw new Error("Original file not found");

    const audioData = await original.arrayBuffer();

    // process audio (this is where FFmpeg WASM or external service is called)
    const { playbackBuffer, waveformData, duration } = await processAudio(audioData);

    // store processed files
    await env.R2.put(msg.targetPlaybackKey, playbackBuffer, {
      httpMetadata: { contentType: "audio/mpeg" },
    });

    await env.R2.put(msg.targetWaveformKey, JSON.stringify(waveformData), {
      httpMetadata: { contentType: "application/json" },
    });

    // update database
    await env.DB.prepare(
      `UPDATE track_version 
       SET processing_status = 'complete', 
           playback_key = ?, 
           waveform_key = ?, 
           duration = ? 
       WHERE id = ?`
    ).bind(msg.targetPlaybackKey, msg.targetWaveformKey, duration, msg.versionId).run();

  } catch (error) {
    await env.DB.prepare(
      `UPDATE track_version SET processing_status = 'failed' WHERE id = ?`
    ).bind(msg.versionId).run();
    throw error;
  }
}
```

## Retry Logic

Configure retry behavior in wrangler.jsonc:

```jsonc
{
  "queues": {
    "consumers": [
      {
        "queue": "audio-processing",
        "max_retries": 3,
        "retry_delay": "exponential",
        "dead_letter_queue": "audio-processing-dlq"
      }
    ]
  }
}
```

## Monitoring Queue Status

```typescript
// Check processing status from client
const getProcessingStatus = createServerFn({ method: "GET" })
  .validator((versionId: string) => versionId)
  .handler(async ({ data: versionId }) => {
    const { env } = await getCloudflareContext();
    
    const version = await env.DB.prepare(
      `SELECT processing_status, duration FROM track_version WHERE id = ?`
    ).bind(versionId).first();
    
    return version;
  });
```

## Key Patterns

1. Use typed messages for type safety
2. Set `max_batch_size: 1` for CPU-intensive tasks like audio processing
3. Always update database status before and after processing
4. Use dead letter queues for failed messages
5. Implement idempotent processing (safe to retry)
6. Consider external services for heavy processing (Workers have CPU limits)
7. Use exponential backoff for retries
