---
description: TanStack Start server functions with createServerFn
globs: ["src/lib/server/**/*.ts", "src/routes/**/*.ts", "src/routes/**/*.tsx"]
---

# TanStack Start Server Functions

> Reference: https://tanstack.com/start/latest/docs/framework/solid/guide/server-functions

## What are Server Functions?

Server functions run on the server but can be called from anywhere - loaders, components, hooks, or other server functions. They provide type-safe RPC with automatic serialization.

## Basic Usage

```typescript
import { createServerFn } from "@tanstack/solid-start/server";

// simple server function (no params)
export const getServerTime = createServerFn({ method: "GET" })
  .handler(async () => {
    return new Date().toISOString();
  });

// server function with parameters
export const getUser = createServerFn({ method: "GET" })
  .validator((userId: string) => userId)
  .handler(async ({ data }) => {
    // data is typed as string (from validator)
    return await db.users.findById(data);
  });
```

## HTTP Methods

```typescript
// GET - for fetching data (cacheable, no side effects)
export const getTracks = createServerFn({ method: "GET" })
  .handler(async () => {
    return await db.tracks.findMany();
  });

// POST - for mutations (creating, updating, deleting)
export const createTrack = createServerFn({ method: "POST" })
  .validator((data: { title: string }) => data)
  .handler(async ({ data }) => {
    return await db.tracks.create(data);
  });
```

## Validation

### Basic Validation

```typescript
export const createTrack = createServerFn({ method: "POST" })
  .validator((data: { title: string; description?: string }) => data)
  .handler(async ({ data }) => {
    // data is fully typed
    console.log(data.title);      // string
    console.log(data.description); // string | undefined
  });
```

### Validation with Zod

```typescript
import { z } from "zod";

const trackSchema = z.object({
  title: z.string().min(1).max(100),
  description: z.string().optional(),
  isPublic: z.boolean().default(false),
});

export const createTrack = createServerFn({ method: "POST" })
  .validator(trackSchema)
  .handler(async ({ data }) => {
    // data is typed from zod schema
    return await db.tracks.create(data);
  });
```

### Optional Parameters

```typescript
// parameters with defaults
export const fetchTracks = createServerFn({ method: "GET" })
  .validator((data?: { limit?: number; offset?: number }) => data ?? {})
  .handler(async ({ data }) => {
    const limit = data.limit ?? 20;
    const offset = data.offset ?? 0;
    return await db.tracks.findMany({ take: limit, skip: offset });
  });
```

## Calling Server Functions

### In Route Loaders

```typescript
// src/routes/index.tsx
import { createFileRoute } from "@tanstack/solid-router";
import { fetchTracks } from "~/lib/server/tracks";

export const Route = createFileRoute("/")({
  loader: async () => {
    // call with data property
    return fetchTracks({ data: { limit: 20, offset: 0 } });
  },
  component: HomePage,
});
```

### In Components

```typescript
import { createResource } from "solid-js";
import { getTracks } from "~/lib/server/tracks";

function TrackList() {
  // with createResource for reactive data
  const [tracks] = createResource(() => getTracks());
  
  return (
    <For each={tracks()}>
      {(track) => <div>{track.title}</div>}
    </For>
  );
}
```

### Direct Calls (Mutations)

```typescript
import { createTrack } from "~/lib/server/tracks";

function CreateTrackForm() {
  const handleSubmit = async (e: Event) => {
    e.preventDefault();
    
    // call server function directly
    const result = await createTrack({
      data: { title: "New Track", description: "My new track" }
    });
    
    console.log("Created:", result);
  };
  
  return <form onSubmit={handleSubmit}>...</form>;
}
```

## Error Handling

### Basic Errors

```typescript
export const deleteTrack = createServerFn({ method: "POST" })
  .validator((trackId: string) => trackId)
  .handler(async ({ data: trackId }) => {
    const track = await db.tracks.findById(trackId);
    
    if (!track) {
      throw new Error("Track not found");
    }
    
    await db.tracks.delete(trackId);
    return { deleted: true };
  });
```

### Redirects

```typescript
import { redirect } from "@tanstack/solid-router";

export const createTrack = createServerFn({ method: "POST" })
  .validator((data: { title: string }) => data)
  .handler(async ({ data }) => {
    const track = await db.tracks.create(data);
    
    // redirect after creation
    throw redirect({
      to: "/track/$trackId",
      params: { trackId: track.id },
    });
  });
```

### Not Found

```typescript
import { notFound } from "@tanstack/solid-router";

export const getTrack = createServerFn({ method: "GET" })
  .validator((trackId: string) => trackId)
  .handler(async ({ data: trackId }) => {
    const track = await db.tracks.findById(trackId);
    
    if (!track) {
      throw notFound();
    }
    
    return track;
  });
```

## Server Context

### Accessing Request/Response

```typescript
import { getWebRequest, setResponseStatus } from "@tanstack/solid-start/server";

export const getUserFromCookie = createServerFn({ method: "GET" })
  .handler(async () => {
    // get the incoming request
    const request = getWebRequest();
    const cookies = request.headers.get("cookie");
    
    // parse and validate session
    const session = parseSessionFromCookies(cookies);
    
    if (!session) {
      setResponseStatus(401);
      throw new Error("Unauthorized");
    }
    
    return session.user;
  });
```

### With Cloudflare Context

```typescript
import { getCloudflareContext } from "@tanstack/solid-start/cloudflare";

export const getTracks = createServerFn({ method: "GET" })
  .handler(async () => {
    // access cloudflare bindings (D1, R2, KV, etc.)
    const { env } = await getCloudflareContext();
    
    const { results } = await env.DB.prepare(`SELECT * FROM track`).all();
    return results;
  });
```

## Middleware

Server functions can use middleware for shared logic like authentication.

```typescript
import { createMiddleware } from "@tanstack/solid-start/server";

// define reusable middleware
const authMiddleware = createMiddleware()
  .server(async ({ next }) => {
    const session = await getSession();
    if (!session?.user) {
      throw redirect({ to: "/auth/login" });
    }
    // pass context to next handler
    return next({ context: { session } });
  });

// use middleware in server function
export const createTrack = createServerFn({ method: "POST" })
  .middleware([authMiddleware])
  .validator((data: { title: string }) => data)
  .handler(async ({ data, context }) => {
    // context.session available from middleware
    const userId = context.session.user.id;
    return await db.tracks.create({ ...data, userId });
  });
```

## Form Data

```typescript
export const uploadFile = createServerFn({ method: "POST" })
  .validator((formData: FormData) => formData)
  .handler(async ({ data: formData }) => {
    const file = formData.get("file") as File;
    const title = formData.get("title") as string;
    
    // handle file upload
    const buffer = await file.arrayBuffer();
    await storage.put(file.name, buffer);
    
    return { uploaded: true, filename: file.name };
  });
```

## Streaming Responses

```typescript
export const streamData = createServerFn({ method: "GET" })
  .handler(async function* () {
    for (let i = 0; i < 10; i++) {
      yield { chunk: i };
      await new Promise((r) => setTimeout(r, 100));
    }
  });
```

## Best Practices

1. **Organize by feature** - Group server functions in `src/lib/server/[feature].ts`
2. **Use GET for reads, POST for writes** - GET responses can be cached
3. **Always validate input** - Use `.validator()` for type safety
4. **Handle errors gracefully** - Throw appropriate errors for client handling
5. **Use middleware for auth** - Share authentication logic across functions
6. **Keep functions focused** - One function, one responsibility
